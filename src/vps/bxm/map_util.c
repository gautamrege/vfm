/*
 * Copyright (c) 2008  VirtualPlane Systems, Inc.
 */

#include<stdio.h>
#include<stdint.h>
#include<common.h>
#include<map_util.h>

/*Global : map for request entry map for FC request*/
req_entry_map* g_req_map[REQ_ENTRY_MAP_LEN];
pthread_mutex_t map_mutex = PTHREAD_MUTEX_INITIALIZER;

/*OXID index generated by VFM for every request */
static uint16_t vfm_oxid_index = 1;

/*
 * Add Entry to map
 *
 * [IN] oxid           : Originator Exchange ID.
 * [IN] mac                : Mac aadress of requester.
 *
 * Return :vfm_gen_oxid VFM generated OXID.or if 0 then no empty index.
 */
uint16_t
add_entry_to_map(req_entry_map *entry)
{
        vps_trace(VPS_ENTRYEXIT, "Entering add_entry_to_map");

        uint16_t temp_index = 0;
        int i = 0;

        pthread_mutex_lock(&map_mutex);
        /*If vfm oxid index greater then max limit of map pointer array*/
        if (vfm_oxid_index >= REQ_ENTRY_MAP_LEN ||
                        g_req_map[vfm_oxid_index] != NULL) {
                vfm_oxid_index = 1;

                for (i = 1; i < REQ_ENTRY_MAP_LEN; i++) {
                        /*Find empty index in map*/
                        if (g_req_map[i] == NULL) {
                                vfm_oxid_index = i;
                                break;
                        }
                }
        }

        /*Allocate memory and assign values*/
        g_req_map[vfm_oxid_index] =
                (req_entry_map *)malloc(sizeof(req_entry_map));

        /*Set value of oxid and requester mac*/
        memcpy(g_req_map[vfm_oxid_index], entry, sizeof(req_entry_map));

        /*Set vfm generated oxid*/
        temp_index = vfm_oxid_index;

        /*Increment vfm genration oxid index by 1*/
        vfm_oxid_index++;
        vps_trace(VPS_INFO, "Adding map key: %d  added index : %x ",
                        temp_index, g_req_map[temp_index]->oxid);
        pthread_mutex_unlock(&map_mutex);

out:
        vps_trace(VPS_ENTRYEXIT, "Leaving add_entry_to_map");
        return temp_index;
}

/*
 * Remove  Entry from map
 *
 * [IN] vfm_gen_oxid : VFM generated  OXID.
 *
 * This method is always called when the map_mutex is locked !!
 *
 */
void
remove_entry_from_map(uint16_t vfm_gen_oxid)
{
        vps_trace(VPS_ENTRYEXIT, "Entering remove_entry_from_map");

        pthread_mutex_lock(&map_mutex);
        vps_trace(VPS_INFO, "Removing map key: %d", vfm_gen_oxid);

        /*Index For given oxid not null then free  */
        if (g_req_map[vfm_gen_oxid] !=  NULL) {
           free(g_req_map[vfm_gen_oxid]);
           vfm_oxid_index = vfm_gen_oxid;
        }
        pthread_mutex_unlock(&map_mutex);

out:
        vps_trace(VPS_ENTRYEXIT, "Entering add_entry_to_map");
}

/*
 * Get Entry from map
 *
 * [IN] vfm_gen_oxid : VFM generated  OXID.
 * [OUT] oxid                : Original oxid of requester.
 * [OUT] mac                 : Requester mac address.
 *
 * Return : err
 *                  No entry for given oxid.
 */
req_entry_map*
get_entry_from_map(uint16_t vfm_gen_oxid)
{

        req_entry_map *entry = NULL;

        vps_trace(VPS_ENTRYEXIT, "Entering get_entry_from_map");

        pthread_mutex_lock(&map_mutex);

        if (g_req_map[vfm_gen_oxid] !=  NULL) {
                /*Set value of oxid and requested mac*/
                entry = g_req_map[vfm_gen_oxid];

                vps_trace(VPS_INFO, "Got map key %d value : %x", vfm_gen_oxid,
                          g_req_map[vfm_gen_oxid]->oxid);
        }
        pthread_mutex_unlock(&map_mutex);

        vps_trace(VPS_ENTRYEXIT, "Leaving get_entry_from_map");
        return entry;
}

/*
 * Free all entry from map.
 */
void free_map()
{
        vps_error err = VPS_SUCCESS;
        int i;
        vps_trace(VPS_ENTRYEXIT, "Entering free_map");

        for (i = 0; i< REQ_ENTRY_MAP_LEN; i++) {
                if (g_req_map[i] !=  NULL) {
                        free(g_req_map[i]);
                }
        }

        vps_trace(VPS_ENTRYEXIT, "Leaving free_map");
}
